#!/usr/bin/env python3
"""Build deterministic startup data assets for a Flutter app."""

from __future__ import annotations

import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


def _fail(message: str) -> None:
    print(f"ERROR: {message}", file=sys.stderr)
    raise SystemExit(1)


def _load_yaml(path: Path) -> Dict[str, Any]:
    if not path.exists():
        _fail(f"Missing YAML file: {path}")
    try:
        import yaml  # type: ignore
    except Exception:
        _fail("Missing dependency: PyYAML is required to parse startup_data.yaml")
    try:
        data = yaml.safe_load(path.read_text(encoding="utf-8"))
    except Exception as exc:
        _fail(f"Malformed YAML in {path}: {exc}")
    if not isinstance(data, dict):
        _fail("startup_data.yaml must contain a top-level mapping")
    return data


def _normalize_string(value: Any, field: str) -> str:
    if not isinstance(value, str) or not value.strip():
        _fail(f"Invalid or missing '{field}' value")
    return value.strip()


def _validate_data_files(
    data: Dict[str, Any],
    project_root: Path,
) -> List[Dict[str, Any]]:
    raw_files = data.get("data_files")
    if not isinstance(raw_files, list):
        _fail("startup_data.yaml must define a 'data_files' list")

    validated: List[Dict[str, Any]] = []
    for idx, entry in enumerate(raw_files, start=1):
        if not isinstance(entry, dict):
            _fail(f"data_files entry #{idx} must be a mapping")
        name = _normalize_string(entry.get("name"), "name")
        sandbox_name = _normalize_string(entry.get("sandbox_name"), "sandbox_name")
        read_only = entry.get("read_only")
        required = entry.get("required")
        if not isinstance(read_only, bool):
            _fail(f"Invalid or missing 'read_only' value for {name}")
        if not isinstance(required, bool):
            _fail(f"Invalid or missing 'required' value for {name}")

        asset_path_value = entry.get("asset_path")
        asset_path: Optional[str]
        if asset_path_value is None or str(asset_path_value).strip() == "":
            asset_path = None
        else:
            asset_path = _normalize_string(asset_path_value, "asset_path")

        if read_only and not asset_path:
            _fail(f"read_only file missing asset_path: {name}")

        if asset_path:
            asset_file = project_root / asset_path
            if not asset_file.exists():
                _fail(f"Missing asset file: {asset_path}")
            size = asset_file.stat().st_size
            if size == 0:
                _fail(f"Asset file is empty: {asset_path}")
            print(f"Verified asset: {asset_path} ({size} bytes)")

        validated.append(
            {
                "name": name,
                "asset_path": asset_path,
                "sandbox_name": sandbox_name,
                "read_only": read_only,
                "required": required,
            }
        )

    return validated


def _dart_escape(value: str) -> str:
    return value.replace("\\", "\\\\").replace("'", "\\'")


def _render_startup_data_files(
    data_files: List[Dict[str, Any]],
    sandbox_subdir: str,
) -> str:
    lines: List[str] = []
    lines.append("// Generated by dlbBuildBaseApp.py. Do not edit by hand.")
    lines.append("")
    lines.append(
        f"const String startupSandboxSubdir = '{_dart_escape(sandbox_subdir)}';"
    )
    lines.append("")
    lines.append("class StartupDataFile {")
    lines.append("  final String name;")
    lines.append("  final String? assetPath;")
    lines.append("  final String sandboxName;")
    lines.append("  final bool readOnly;")
    lines.append("  final bool required;")
    lines.append("")
    lines.append("  const StartupDataFile({")
    lines.append("    required this.name,")
    lines.append("    required this.assetPath,")
    lines.append("    required this.sandboxName,")
    lines.append("    required this.readOnly,")
    lines.append("    required this.required,")
    lines.append("  });")
    lines.append("}")
    lines.append("")
    lines.append("const List<StartupDataFile> startupDataFiles = [")
    for entry in data_files:
        asset_literal = (
            "null"
            if entry["asset_path"] is None
            else f"'{_dart_escape(entry['asset_path'])}'"
        )
        lines.append("  StartupDataFile(")
        lines.append(f"    name: '{_dart_escape(entry['name'])}',")
        lines.append(f"    assetPath: {asset_literal},")
        lines.append(f"    sandboxName: '{_dart_escape(entry['sandbox_name'])}',")
        lines.append(f"    readOnly: {str(entry['read_only']).lower()},")
        lines.append(f"    required: {str(entry['required']).lower()},")
        lines.append("  ),")
    lines.append("];")
    lines.append("")
    return "\n".join(lines)


def _render_startup_data_verification() -> str:
    lines: List[str] = []
    lines.append("// Generated by dlbBuildBaseApp.py. Do not edit by hand.")
    lines.append("")
    lines.append("import 'dart:io';")
    lines.append("")
    lines.append("import 'package:flutter/foundation.dart';")
    lines.append("import 'package:flutter/services.dart';")
    lines.append("import 'package:path/path.dart' as p;")
    lines.append("import 'package:path_provider/path_provider.dart';")
    lines.append("import 'package:sqflite/sqflite.dart';")
    lines.append("")
    lines.append("import 'startup_data_files.dart';")
    lines.append("")
    lines.append("Future<Directory> _resolveSandboxDirectory() async {")
    lines.append("  final supportDir = await getApplicationSupportDirectory();")
    lines.append("  var basePath = supportDir.path;")
    lines.append("  if (p.basename(basePath) == 'Documents') {")
    lines.append("    basePath = p.join(p.dirname(basePath), 'Library', 'Application Support');")
    lines.append("  }")
    lines.append("  final dir = startupSandboxSubdir.isEmpty")
    lines.append("      ? Directory(basePath)")
    lines.append("      : Directory(p.join(basePath, startupSandboxSubdir));")
    lines.append("  await dir.create(recursive: true);")
    lines.append("  return dir;")
    lines.append("}")
    lines.append("")
    lines.append("Future<void> _copyAssetToFile(String assetPath, File destination) async {")
    lines.append("  final data = await rootBundle.load(assetPath);")
    lines.append("  final bytes = data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);")
    lines.append("  await destination.writeAsBytes(bytes, flush: true);")
    lines.append("}")
    lines.append("")
    lines.append("bool _isDbFile(String path) {")
    lines.append("  return path.toLowerCase().endsWith('.db');")
    lines.append("}")
    lines.append("")
    lines.append("Future<void> _verifyFileOpen(StartupDataFile file, String path) async {")
    lines.append("  if (_isDbFile(path)) {")
    lines.append("    final db = await openDatabase(path, readOnly: file.readOnly);")
    lines.append("    await db.rawQuery('SELECT name FROM sqlite_master LIMIT 1');")
    lines.append("    await db.close();")
    lines.append("    return;")
    lines.append("  }")
    lines.append("  final raf = await File(path).open(")
    lines.append("    mode: file.readOnly ? FileMode.read : FileMode.append,")
    lines.append("  );")
    lines.append("  await raf.close();")
    lines.append("}")
    lines.append("")
    lines.append("Future<void> verifyAndPrepareStartupData() async {")
    lines.append("  final files = startupDataFiles;")
    lines.append("  if (files.isEmpty) {")
    lines.append("    return;")
    lines.append("  }")
    lines.append("  final sandboxDir = await _resolveSandboxDirectory();")
    lines.append("  for (final file in files) {")
    lines.append("    final sandboxPath = p.join(sandboxDir.path, file.sandboxName);")
    lines.append("    final sandboxFile = File(sandboxPath);")
    lines.append("    final exists = await sandboxFile.exists();")
    lines.append("    var status = 'verified';")
    lines.append("    if (!exists) {")
    lines.append("      if (file.readOnly) {")
    lines.append("        final assetPath = file.assetPath;")
    lines.append("        if (assetPath == null || assetPath.isEmpty) {")
    lines.append("          throw StateError('Missing assetPath for readOnly file: ${file.name}');")
    lines.append("        }")
    lines.append("        await _copyAssetToFile(assetPath, sandboxFile);")
    lines.append("        status = 'copied';")
    lines.append("      } else {")
    lines.append("        if (file.assetPath != null && file.assetPath!.isNotEmpty) {")
    lines.append("          await _copyAssetToFile(file.assetPath!, sandboxFile);")
    lines.append("          status = 'copied';")
    lines.append("        } else if (_isDbFile(sandboxPath)) {")
    lines.append("          final db = await openDatabase(sandboxPath);")
    lines.append("          await db.close();")
    lines.append("          status = 'created';")
    lines.append("        } else {")
    lines.append("          await sandboxFile.create(recursive: true);")
    lines.append("          if (file.required) {")
    lines.append("            await sandboxFile.writeAsString('\\n', flush: true);")
    lines.append("          }")
    lines.append("          status = 'created';")
    lines.append("        }")
    lines.append("      }")
    lines.append("    }")
    lines.append("    final size = await sandboxFile.length();")
    lines.append("    if (file.required && size == 0) {")
    lines.append("      throw StateError('Required file is empty: ${file.name}');")
    lines.append("    }")
    lines.append("    await _verifyFileOpen(file, sandboxPath);")
    lines.append("    debugPrint(")
    lines.append("      'StartupData: name=${file.name} asset=${file.assetPath ?? "-"} '")
    lines.append("      'sandbox=$sandboxPath size=$size status=$status',")
    lines.append("    );")
    lines.append("  }")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def _write_file_if_changed(path: Path, content: str) -> bool:
    existing = None
    if path.exists():
        existing = path.read_text(encoding="utf-8")
    if existing == content:
        return False
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    return True


def _parse_assets(
    lines: List[str],
    start_idx: int,
    assets_indent: str,
) -> Tuple[List[str], int]:
    assets: List[str] = []
    idx = start_idx + 1
    while idx < len(lines):
        line = lines[idx]
        if line.strip() == "":
            idx += 1
            continue
        if not line.startswith(assets_indent):
            break
        stripped = line.strip()
        if stripped.startswith("-"):
            path = stripped[1:].strip().strip('"').strip("'")
            assets.append(path)
            idx += 1
            continue
        if stripped.startswith("#"):
            idx += 1
            continue
        if not stripped.startswith("-"):
            break
        idx += 1
    return assets, idx


def _update_pubspec(pubspec_path: Path, asset_paths: List[str]) -> bool:
    lines = pubspec_path.read_text(encoding="utf-8").splitlines()
    flutter_idx = None
    flutter_indent = ""
    for idx, line in enumerate(lines):
        if line.strip() == "flutter:":
            flutter_idx = idx
            flutter_indent = line[: len(line) - len(line.lstrip(" "))]
            break
    if flutter_idx is None:
        _fail("pubspec.yaml is missing a 'flutter:' section")

    block_end = len(lines)
    for idx in range(flutter_idx + 1, len(lines)):
        line = lines[idx]
        if line.strip() == "":
            continue
        if line.lstrip(" ") == line:
            block_end = idx
            break
        current_indent = line[: len(line) - len(line.lstrip(" "))]
        if len(current_indent) <= len(flutter_indent) and not line.strip().startswith("#"):
            block_end = idx
            break

    assets_idx = None
    assets_indent = None
    for idx in range(flutter_idx + 1, block_end):
        line = lines[idx]
        if line.strip() == "assets:":
            assets_idx = idx
            assets_indent = line[: len(line) - len(line.lstrip(" "))]
            break

    assets_set = set()
    insert_at = None
    if assets_idx is not None and assets_indent is not None:
        existing_assets, end_idx = _parse_assets(lines, assets_idx, assets_indent)
        assets_set.update(existing_assets)
        insert_at = end_idx
    else:
        assets_indent = flutter_indent + "  "
        list_indent = assets_indent + "  "
        insertion = [f"{assets_indent}assets:"]
        for asset_path in asset_paths:
            insertion.append(f"{list_indent}- {asset_path}")
        insertion.append("")
        new_lines = lines[:block_end] + insertion + lines[block_end:]
        if new_lines != lines:
            pubspec_path.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
            return True
        return False

    list_indent = assets_indent + "  "
    new_entries = [p for p in asset_paths if p not in assets_set]
    if not new_entries:
        return False

    insertion = [f"{list_indent}- {p}" for p in new_entries]
    new_lines = lines[:insert_at] + insertion + lines[insert_at:]
    pubspec_path.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
    return True


def main() -> None:
    project_root = Path(__file__).resolve().parent
    yaml_path = project_root / "startup_data.yaml"
    pubspec_path = project_root / "pubspec.yaml"

    data = _load_yaml(yaml_path)
    data_files = _validate_data_files(data, project_root)

    sandbox_subdir_value = data.get("sandbox_dir")
    sandbox_subdir = ""
    if sandbox_subdir_value is not None and str(sandbox_subdir_value).strip() != "":
        sandbox_subdir = _normalize_string(sandbox_subdir_value, "sandbox_dir")

    dart_files_written = 0
    startup_dir = project_root / "lib" / "startup"

    data_files_content = _render_startup_data_files(data_files, sandbox_subdir)
    if _write_file_if_changed(startup_dir / "startup_data_files.dart", data_files_content):
        print("Generated lib/startup/startup_data_files.dart")
        dart_files_written += 1

    verification_content = _render_startup_data_verification()
    if _write_file_if_changed(
        startup_dir / "startup_data_verification.dart", verification_content
    ):
        print("Generated lib/startup/startup_data_verification.dart")
        dart_files_written += 1

    asset_paths = [
        entry["asset_path"] for entry in data_files if entry["asset_path"]
    ]
    pubspec_modified = _update_pubspec(pubspec_path, asset_paths)
    if pubspec_modified:
        print("Updated pubspec.yaml assets")

    print(
        "Summary: "
        f"verified {len(data_files)} files, "
        f"generated {dart_files_written} Dart files, "
        f"pubspec.yaml modified: {'yes' if pubspec_modified else 'no'}"
    )


if __name__ == "__main__":
    main()
